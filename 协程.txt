使用普通的yield实现的协程其实功能很有限。
Python虚拟机的原理是通过对栈帧对象PyFrameObject抽象出运行时(栈、指令、符号表、常量表),
通过执行PyEval_EvalFrameEx这个C级别的函数来逐个解析字节码指令，也就是说可调用对象都是通过
PyEval_EvalFrameEx来执行自己的PyFrameObject的，当前PyFrameObject的f_back指针会指向上一个
PyFrameObject，即它的调用者。可以看出，对于Python而言，切换当前栈顶的帧很容易，只要保留栈顶的PyFrameObject，
回退到栈顶的下一帧，这也是yield的基本原理。但是，Python栈帧一开始就不是为协程设计的，所以栈帧之间的这种
执行的先后顺序语言本身没有提供恢复和挂起的机制。这就要求假如你想任意切换上下文，必须实现一个机制，可以保存一个执行栈。

greenlet的切换不同于普通的调用概念，切换是在不同的栈帧之间切换，而调用是在当前的栈顶之上，创建新的调用栈，很相似，略有不同，不必计较。
